buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'javax.inject:javax.inject:1'
    }
}

plugins {
    id 'java'
    id 'org.jetbrains.gradle.plugin.idea-ext' version '1.3'
}

import org.gradle.internal.os.OperatingSystem

import javax.inject.Inject

ext {
    os = OperatingSystem.current()

    hytaleDir = "$projectDir/.hytale"
    hytaleDownloaderDir = "$hytaleDir/downloader"
    hytaleProperties = "$hytaleDir/hytale.properties"

    serverRunDir = "$projectDir/run"
    buildMods = "${getLayout().buildDirectory.get()}/mods"
}

sourceSets {
    main {
        resources {
            // Exclude Blockbench and Krita project files.
            exclude "**/*.bbmodel"
            exclude "**/*.kra"

            // Exclude backup files
            exclude "**/*~"
            exclude "**/*.bak"
        }
    }
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(java_version)

    withSourcesJar()
    withJavadocJar()
}

//def hytale_properties = new Properties()
//def properties_file = file ext.hytaleProperties
//
//if (properties_file.exists()) {
//    hytale_properties.load(file(ext.hytaleProperties).newReader())
//} else {
//    // Get the Hytale maven manifest file for the current patchline.
//    def manifestUrl = "https://maven.hytale.com/$patchline/com/hypixel/hytale/Server/maven-metadata.xml"
//    def manifestXml = new XmlSlurper().parse(manifestUrl)
//
//    def latest_version = manifestXml.versioning.latest
//
//    hytale_properties.setProperty("patchline", "$patchline")
//    hytale_properties.setProperty("version", "$latest_version")
//}
//
//// Get Hytale version properties
//def hytale_patchline = hytale_properties.getProperty("patchline")
//def hytale_version = hytale_properties.getProperty("version")
//
//repositories {
//    mavenCentral()
//
//    // Hytale Maven repository
//    maven {
//        name = "hytale"
//        url = uri "https://maven.hytale.com/$hytale_patchline"
//    }
//}

dependencies {
//    compileOnly "com.hypixel.hytale:Server:$hytale_version"

    // Add the Hytale server as a dependency so we can build and use their code.
    def serverJar = file "$serverRunDir/Server/HytaleServer.jar"
    if (serverJar.exists()){
        implementation files(serverJar)
    }
}

processResources {
    filesMatching('**/manifest.json') {
        expand project.properties
    }
}

tasks.register('updateHytaleDownloader') {
    description = 'Downloads the latest Hytale Downloader CLI tool into .hytale/downloader.'
    group = 'Hytale'

    doLast {
        mkdir hytaleDir

        // TODO: use the Hytale Downloader tool to check for updates, only update if a new version is available
        if (!file("$hytaleDownloaderDir").exists()) {
            // Download and unzip Hytale Downloader
            ant.get(
                    src: 'https://downloader.hytale.com/hytale-downloader.zip',
                    dest: "${hytaleDownloaderDir}.zip",
            )
            ant.unzip(
                    src: "${hytaleDownloaderDir}.zip",
                    dest: hytaleDownloaderDir
            )
            // Delete the .zip file
            delete "${hytaleDownloaderDir}.zip"

            // TODO: authenticate here, rather than specifically when updating the server? maybe authentication should
            //       be a separate task which can be run both here and when updating the server if no credentials file
            //       is found
        } else {
            println 'Hytale Downloader is already installed; skipping installation.'
        }
    }
}

abstract class UpdateHytaleServerTask extends DefaultTask {
    private ExecOperations execOps
    private OperatingSystem operatingSystem

    @InputDirectory
    abstract DirectoryProperty getHytaleDownloaderDir()
    @Input
    abstract Property<String> getPatchline()

    @OutputFile
    abstract RegularFileProperty getHytalePropertiesFile()
    @OutputDirectory
    abstract DirectoryProperty getRunDir()

    @Inject
    UpdateHytaleServerTask(ExecOperations execOps) {
        this.execOps = execOps
        this.operatingSystem = OperatingSystem.current()
    }

    @TaskAction
    void run() {
        def dir = hytaleDownloaderDir.asFile.get()
        def run_dir = runDir.asFile.get()
        def properties_file = hytalePropertiesFile.asFile.get()

        def os = this.operatingSystem
        // Executable location based on OS
        def exe = ''
        if (os.isWindows()) {
            exe = "$dir/hytale-downloader-windows-amd64.exe"
        } else {
            exe = "$dir/hytale-downloader-linux-amd64"
        }

        // TODO: authenticate Hytale Downloader with a task
        println 'Provoking authentication by using Hytale Downloader to print current Hytale version...'
        execOps.exec {
            executable exe
            workingDir dir
            args '-patchline', patchline.get(), '-print-version'
        }

        // Retrieve previous version, if already installed
        def old_version = ''
        if (properties_file.exists()) {
            def props = new Properties()
            props.load(properties_file.newReader())

            old_version = props.version
        }
        // Get the version that will be downloaded
        def version_out = new ByteArrayOutputStream()
        execOps.exec {
            executable exe
            workingDir dir
            args '-patchline', patchline.get(), '-print-version'

            standardOutput = version_out
        }
        def new_version = version_out.toString().trim()

        // Download the server if installation or an update is required
        if (
                new_version != old_version
                        || !new File("$run_dir/Server/HytaleServer.jar").exists()
                        || !new File("$run_dir/Assets.zip").exists()
        ) {
            // Store the game version used
            ant.propertyfile(file: hytalePropertiesFile.asFile.get()) {
                entry(key: "patchline", value: patchline.get())
                entry(key: "version", value: new_version)
            }

            // Download Hytale
            execOps.exec {
                workingDir dir
                executable exe
                args '-patchline', patchline.get(), '-download-path', "latest.zip"

                standardInput = System.in
                standardOutput = System.out
            }
        } else {
            println 'Hytale server is already up to date; skipping update.'
            return
        }

        // Unzip to run directory
        ant.unzip(
                src: "$dir/latest.zip",
                dest: run_dir
        )

        if (!old_version.empty && new_version != old_version) {
            println "Updated Hytale server from version $old_version to $new_version"
        }  else {
            println "Installed Hytale server version $new_version"
        }
    }
}

tasks.register('updateHytaleServer', UpdateHytaleServerTask) {
    dependsOn updateHytaleDownloader
    group = 'Hytale'
    description = 'Downloads/updates to the latest Hytale version.'

    hytaleDownloaderDir = file project.ext.hytaleDownloaderDir
    patchline = project.ext.patchline

    hytalePropertiesFile = file project.ext.hytaleProperties
    runDir = file project.ext.serverRunDir
}

// The HytaleServer.jar file updated in the updateHytaleServer task is a project dependency, thus installing that file
// in the first place is a dependency for compilation.
compileJava.mustRunAfter updateHytaleServer
javadoc.mustRunAfter updateHytaleServer

abstract class RunHytaleServerTask extends DefaultTask {
    private ExecOperations execOps
    private OperatingSystem os

    @InputDirectory
    abstract DirectoryProperty getModsDir()
    @InputDirectory
    abstract DirectoryProperty getResourcesDir()
    @InputDirectory
    abstract DirectoryProperty getRunDir()

    @Inject
    RunHytaleServerTask(ExecOperations execOps) {
        this.execOps = execOps
        this.os = OperatingSystem.current()

        setGroup 'Hytale'
    }

    def createServerRunArguments() {
        def programParameters = ['--allow-op', '--disable-sentry']
        def modPaths = [modsDir.get(), resourcesDir.get()]

        if (!modPaths.isEmpty()) {
            programParameters += '--mods="' + modPaths.join(',') + '"'
        }

        return programParameters
    }

    @TaskAction
    void run() {
        def dir = runDir.get()

        def exe = 'start.sh'
        if (os.isWindows()) {
            exe = 'start.bat'
        }

        execOps.exec {
            workingDir dir
            executable "$dir/$exe"
            createServerRunArguments().forEach { arg -> args arg }

            standardInput = System.in
            standardOutput = System.out
        }
    }
}

tasks.register('runHytaleServer', RunHytaleServerTask) {
    dependsOn updateHytaleServer
    dependsOn build
    mustRunAfter copyJar

    description = """
        Builds the mod and runs the Hytale server.
        
        You can connect on your client with 127.0.0.1."""

    modsDir = file buildMods
    // src/main is treated as a mod directory so that src/main/resources is loaded as an asset pack to replace the one
    // in the compiled jar. Why would you want this? Well, purely so that the Asset Editor can edit the source code
    // files in real time.
    resourcesDir = file 'src/main'
    runDir = file serverRunDir
}

tasks.register('copyJar', Copy) {
    group = "Build"
    description = "Copies the built mod jar file into build/mods for use in the Hytale server."

    from jar
    into buildMods

    doFirst {
        delete buildMods
        mkdir buildMods
    }
}

build.finalizedBy copyJar

clean.doFirst {
    delete buildMods
}

idea.project.settings.runConfigurations {
    // Run configuration to run the `runHytaleServer` task.
    "Run Hytale Server"(org.jetbrains.gradle.ext.Gradle) {
        taskNames = ['runHytaleServer']
    }
}
